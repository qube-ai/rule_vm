# Virtual Machine

## Higher level objective
The goal of this system is:
  - Support instructions/commands that make rules express and check powerful things
  - Map instructions as close to real world sentences, making it easier to model

## What kind of information do I have to accept from the user?
Depending on the kind of data I have to accept from the user. 
My data representation format and serialization will be choosen.
Here are the list of operations:
  - `<Time, HH:MM, Recurrence Count>` : At this particular time, it becomes true for **Reccurence Count** number of times.
  - `<Energy Meter, Device ID, Variable, Comparison OP, Value>` - To compare values coming in from energy meter.
  Possible values of **Variable** is:
    - Voltage
    - Current
    - Real Power
    - Apparent Power
    - Power Factor
    - Frequency
  - `<Door Window, Device ID, State, For how long(min)>` - Use current values from door window sensor to evaluate rules. Possible values of **State** are:
    - Open
    - Close
  - `<Occupancy, Device ID, State, For how long(min)>` - Use current values from occupancy sensor to evaluate rules. Possible values for **State**:
    - Occupied
    - Unoccupied

    These states are synthetic. These states are not generated by the device but is made available by making sense of the incoming data.
  - `<Temperature, Device ID, Comparison OP, Value>` - Compare device's current value for rule validation.
  - `<Relay, Device ID, Appliance, State, For how long(min)>` - Compare the current known state of relay to evaluate a rule.

All known Generic conditions(6) that can be entered by the user:
```
<Time, HH:MM, Recurrence Count>
<Energy Meter, Device ID, Variable, Comparison OP, Value>
<Door Window, Device ID, State, For how long(min)>
<Occupancy, Device ID, State, For how long(min)>
<Temperature, Device ID, Comparison OP, Value>
<Relay, Device ID, Appliance, State, For how long(min)>
```

## What is the objective?
These Generic Conditions are used by the customer to make rules for the system. We need a way to represent and send the information back to the 
Rule Engine which will process and evaluate the rule.

Currently, I want a way to represent the generic conditions in the system that satisfies some criteria and allows the Rule Engine to evaluate the conditions.

## What criteria do you want the representation/data structure to satisfy?
Criterias:
  - **Easy to parse** - Libraries should be available that handle parsing. And it should be simple.
  - **Easy to extend** - Adding new instruction should be fairly simple and straight forward.
  - **Type Checking** - For each variable present in a generic condition, the type of value that can be associated with it is fixed. For example, for parsing **For how long (min)** this number is supposed to be an integer. Anything else, it should throw an error.
  - **Easy expression evaluation** - Evaluating expressions should be simple and easy.



## What data serialization format should be used?
Some options are:
  - JSON
  - BSON
  - Resource Description Framework
  - XML
  - Assembly level like language
  - YAML
Since JSON is the most widely used and easily parsable format. We'll use **JSON**.

## How would the expressions be evaluated?
When the conditional expression is generated on the react side, it will be in infix form. As soon as we receive it on the backed. It will be converted into postfix form for easier evaluation using a stack.

## JSON representation

### Energy Meter
Generic condition: `<Energy Meter, Device ID, Variable, Comparison OP, Value>`

JSON representation
```json
{
    "type":"energy_meter",
    "device_id": "podnet-switch-1",
    "variable": "voltage",
    "comparison_op": "=",
    "value": 21
}
```

### Door Window

Generic condition: `<Door Window, Device ID, State, For how long(min)>`

JSON representation:
```json
{
    "type": "door_window",
    "device_id": "dw-1",
    "state": "open",
    "for": 21
}
```

### Occupancy Sensor
Generic condition: `<Occupancy, Device ID, State, For how long(min)>`

JSON representation:
```json
{
    "type": "occupancy",
    "device_id": "occupancy-1",
    "state": "occupied",
    "for": 50
}
```

### Temperature Sensor
Generic condition: `<Temperature, Device ID, Comparison OP, Value>`

JSON representation
```json 
{
    "type": "temperature",
    "device_id": "podnet-switch-1",
    "comparision_op": ">",
    "value": 30
}
```

### Relay State
Generic condition: `<Relay, Device ID, Appliance, State, For how long(min)>`

JSON representation
```json
{
    "type": "relay_state",
    "device_id": "podnet-switch-1",
    "relay_index": 0,
    "state": 1,
    "for": 20
}
```

## Ideal JSON representation design
Since the objective of the rule engine is to support expressions in the real world that are used by the people. We would need instructions that are close to the real world, making it easier to write rules.

Possible rules one might want to create:
  - Sentence: `Turn on the balcony lights at 6 PM everyday`. Conditions:
    - At 6 PM

  - Sentence: `Turn off the water pump when the water tank is full`. Conditions:
    - When water tank is full.

  - Sentence: `If the temperature outside is below 30 degree centigrade, turn off the AC`. Conditions:
    - Temperature outside less than 30 degree centigrade

```json

// Logical AND
{
  "operation": "logical_and"
}

// Logical OR
{
  "operation": "logical_or"
}

// Is it past 6PM? Is it before 4PM?
{
    "operation": "at_time",
    "time": "<ISO datetime with timezone>"
}

// Turn off the balcony lights at 6PM everyday for 10 times.
{
  "operation": "at_time_for_x_occurence",
  "time": "<ISO datetime with timezone>",
  "occurence": 10
}

/* Podnet Switch */
// Is relay0 of podnet-switch-1, on? Is relay3 of podnet-switch-6, off?
{
    "operation": "is_relay_state",
    "device_id": "podnet-switch-1",
    "relay_index": 0,
    "state": 1
}

// If relay0 of podnet-switch-1 on for more than/less than 10 minutes?
{
    "operation": "is_relay_state_for",
    "device_id": "podnet-switch-1",
    "relay_index": 0,
    "state": 1,
    "time_comparison_operator": "more than",
    "for": 10
}

/* Temperature Sensor */
// If temperature is more than 31 degree celcius.
{
    "operation": "check_temperature",
    "device_id": "podnet-switch-1",
    "temp_comparison_op": "more than",
    "value": 31
}

// If the temperature is 30 degree for more than 15 minutes, turn on the heater.
{
    "operation": "check_temperature_for",
    "device_id": "podnet-switch-1",
    "value": 30,
    "temp_comparison_op": "equal",
    "time_comparison_op": "more than",
    "for": 15
}

/* Door Window Sensor */
// Is dw1 open?
{
    "operation": "door_window_state",
    "device_id": "dw-1",
    "state": "open"
}

// Is dw1 open for more than 10 minutes?
{
    "operation": "door_window_state_for",
    "device_id": "dw-1",
    "state": "open",
    "for": 20
}

/* Occupancy Sensor */
// Is the room occupied for more than 5 minutes?
{
    "operation": "check_occupancy_for",
    "device_id": "occupancy-1",
    "state": "occupied",
    "time_comparison_operator": "more than",
    "for": 5
}

// Is the room occupied?
{
    "operation": "check_occupancy",
    "device_id": "occupancy-1",
    "state": "occupied"
}

```

## Construct

**Rule** contains a list of **conditions**. Each condition must be evaluated before a rule can be evaluated.
