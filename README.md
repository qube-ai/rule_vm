# Virtual Machine

## Higher level objective
The goal of this system is:
  - Support instructions/commands that make rules express and check powerful things
  - Map instructions as close to real world sentences, making it easier to model

## What kind of information do I have to accept from the user?
Depending on the kind of data I have to accept from the user. 
My data representation format and serialization will be choosen.
Here are the list of operations:
  - `<Time, HH:MM, Recurrence Count>` : At this particular time, it becomes true for **Reccurence Count** number of times.
  - `<Energy Meter, Device ID, Variable, Comparison OP, Value>` - To compare values coming in from energy meter.
  Possible values of **Variable** is:
    - Voltage
    - Current
    - Real Power
    - Apparent Power
    - Power Factor
    - Frequency
  - `<Door Window, Device ID, State, For how long(min)>` - Use current values from door window sensor to evaluate rules. Possible values of **State** are:
    - Open
    - Close
  - `<Occupancy, Device ID, State, For how long(min)>` - Use current values from occupancy sensor to evaluate rules. Possible values for **State**:
    - Occupied
    - Unoccupied

    These states are synthetic. These states are not generated by the device but is made available by making sense of the incoming data.
  - `<Temperature, Device ID, Comparison OP, Value>` - Compare device's current value for rule validation.
  - `<Relay, Device ID, Appliance, State, For how long(min)>` - Compare the current known state of relay to evaluate a rule.

All known Generic conditions(6) that can be entered by the user:
```
<Time, HH:MM, Recurrence Count>
<Energy Meter, Device ID, Variable, Comparison OP, Value>
<Door Window, Device ID, State, For how long(min)>
<Occupancy, Device ID, State, For how long(min)>
<Temperature, Device ID, Comparison OP, Value>
<Relay, Device ID, Appliance, State, For how long(min)>
```

## What is the objective?
These Generic Conditions are used by the customer to make rules for the system. We need a way to represent and send the information back to the 
Rule Engine which will process and evaluate the rule.

Currently, I want a way to represent the generic conditions in the system that satisfies some criteria and allows the Rule Engine to evaluate the conditions.

## What criteria do you want the representation/data structure to satisfy?
Criterias:
  - **Easy to parse** - Libraries should be available that handle parsing. And it should be simple.
  - **Easy to extend** - Adding new instruction should be fairly simple and straight forward.
  - **Type Checking** - For each variable present in a generic condition, the type of value that can be associated with it is fixed. For example, for parsing **For how long (min)** this number is supposed to be an integer. Anything else, it should throw an error.
  - **Easy expression evaluation** - Evaluating expressions should be simple and easy.



## What data serialization format should be used?
Some options are:
  - JSON
  - BSON
  - Resource Description Framework
  - XML
  - Assembly level like language
  - YAML
Since JSON is the most widely used and easily parsable format. We'll use **JSON**.

## How would the expressions be evaluated?
When the conditional expression is generated on the react side, it will be in infix form. As soon as we receive it on the backed. It will be converted into postfix form for easier evaluation using a stack.

## JSON representation

### Logical Operation
Logical AND
```json
{
  "operation": "logical_and"
}
```

Logical OR
```json
{
  "operation": "logical_or"
}
```

### Time

Is it past 6PM? Is it before 4PM?
```json
{
    "operation": "at_time",
    "time": "<time in RFC3339 format>"
}
```
Example:
```json
{
    "operation": "at_time",
    "time": "18:00:00+05:30"
}
```

Turn off the balcony lights at 6PM everyday for 10 times.
```json
{
  "operation": "at_time_with_occurrence",
  "time": "<time in RFC3339 format>",
  "occurrence": 10
}
```

### Energy Meter
Generic condition: `<Energy Meter, Device ID, Variable, Comparison OP, Value>`

JSON representation
```json
{
    "type":"energy_meter",
    "device_id": "meter-1",
    "variable": "voltage",
    "comparison_op": "=",
    "value": 21
}
```

### Door Window

Generic condition: `<Door Window, Device ID, State, For how long(min)>`

Is dw1 open?
```json
{
    "operation": "door_window_state",
    "device_id": "dw-1",
    "state": "open"
}
```

Is dw1 open for more than 10 minutes? 
```json
{
    "operation": "door_window_state_for",
    "device_id": "dw-1",
    "state": "open",
    "for": 20
}
```

### Occupancy Sensor
Generic condition: `<Occupancy, Device ID, State, For how long(min)>`

JSON representation:
```json
{
    "operation": "check_occupancy_for",
    "device_id": "occupancy-1",
    "state": "occupied",
    "for": 5
}
```

Is the room occupied?
```json
{
    "operation": "check_occupancy",
    "device_id": "occupancy-1",
    "state": "occupied"
}
```

### Temperature Sensor
Generic condition: `<Temperature, Device ID, Comparison OP, Value>`


If temperature is more than 31 degree Celsius.
```json 
{
    "operation": "check_temperature",
    "device_id": "podnet-switch-1",
    "comparison_op": "more than",
    "value": 31
}
```

If the temperature is 30 degree for more than 15 minutes, turn on the heater.
```json
{
    "operation": "check_temperature_for",
    "device_id": "podnet-switch-1",
    "comparison_op": "equal",
    "value": 30,
    "for": 15
}
```

### Relay State
Generic condition: `<Relay, Device ID, Appliance, State, For how long(min)>`

Is relay0 of podnet-switch-1, on? Is relay3 of podnet-switch-6, off?
```json
{
    "operation": "is_relay_state",
    "device_id": "podnet-switch-1",
    "relay_index": 0,
    "state": 1
}
```

If relay0 of podnet-switch-1 on for more than/less than 10 minutes?
```json
{
    "operation": "is_relay_state_for",
    "device_id": "podnet-switch-1",
    "relay_index": 0,
    "state": 1,
    "for": 10
}
```

## Ideal JSON representation design
Since the objective of the rule engine is to support expressions in the real world that are used by the people. We would need instructions that are close to the real world, making it easier to write rules.

Possible rules one might want to create:
  - Sentence: `Turn on the balcony lights at 6 PM everyday`. Conditions:
    - At 6 PM

  - Sentence: `Turn off the water pump when the water tank is full`. Conditions:
    - When water tank is full.

  - Sentence: `If the temperature outside is below 30 degree centigrade, turn off the AC`. Conditions:
    - Temperature outside less than 30 degree centigrade

## Instruction Set

### At time

```
AT_TIME <time in RFC3339 format> 

AT_TIME 18:00:00+05:30
```

### At time with Occurrence
This will become true only when we are past the given time and for the given number of occurences.
```
AT_TIME_WITH_OCCURRENCE <time in RFC3339 format> <no. of times, occurrence>

AT_TIME_WITH_OCCURRENCE 18:00:00+05:30 10
```

### AND
Perform logical AND between the given operands

```
AND
```

### OR
Perform logical OR between the given operands

```
OR
```

### Door Window State
Checks if the door window state is of the given state

```
DW_STATE <device_id> <state: [OPEN | CLOSE]>

DW_STATE dw-1 OPEN
```


### Door Window state for
Checks if the door window state is open/close for given amount of time.

```
DW_STATE_FOR <device_id> <state: [OPEN | CLOSE]> <time in minutes>

DW_STATE_FOR dw-1 OPEN 20
```
This is will check whether dw-1 has been open for more than or equal to 20 minutes.


###  Occupancy Sensing
```
OCCUPANCY_STATE <device_id> <state: [OCCUPIED | UNOCCUPIED]>

OCCUPANCY_STATE os-1 OCCUPIED
```

### Occupancy Sensing for defined time

```
OCCUPANCY_STATE_FOR <device_id> <state: [OCCUPIED | UNOCCUPIED] <time in miunutes>

OCCUPANCY_STATE_FOR os-1 OCCUPIED 20
```
Checks if the room has been occupied for more than or equal to 20 minutes.


### Relay State

```
RELAY_STATE <device_id> <relay_index> <state:[on | off]

RELAY_STATE ps-1 0 on
```
Checks if relay index 0 of ps-1 is switched on.

### Relay state for defined time

```
RELAY_STATE_FOR <device_id> <relay_index> <state:[on | off]> <time in minutes>

RELAY_STATE_FOR ps-1 0 on 15
```
Checks if the state of relay index 0 of device ps-1 is switched on for more than or equal to 15 minutes.

### Temperature

```
TEMPERATURE <device_id> <comparison_op> <value>

TEMPERATURE ps-1 > 30
```
If the temperature of the given device is more than, less than, equal to the given temperature, return true.


### Temperature for defined time
```
TEMPERATURE_FOR <device_id> <comparison_op> <value> <time in minutes>

TEMPERATURE_FOR ps-1 > 30 15
```
If the temperature of ps-1 is more than 30 for more than or equal to 15 minutes.

### Energy Meter
```
ENERGY_METER <device_id> <variable> <comparison_op> <value>

ENERGY_METER <device_id> voltage <comparison_op> <value>
ENERGY_METER <device_id> current <comparison_op> <value>
ENERGY_METER <device_id> real_power <comparison_op> <value>
ENERGY_METER <device_id> apparent_power <comparison_op> <value>
ENERGY_METER <device_id> power_factor <comparison_op> <value: [0.0 to 1.0]>
ENERGY_METER <device_id> frequency <comparison_op> <value>

ENERGY_METER meter-1 power > 120
```
If energy meter meter-1 power is more than 120, return true.